<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Animal Tower Battle</title>

<!-- PWAè¨­å®š -->
<link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIkFuaW1hbCBUb3dlciBCYXR0bGUiLAogICJzaG9ydF9uYW1lIjogIkFuaW1hbCBUb3dlciIsCiAgImRlc2NyaXB0aW9uIjogIuWLleeJqeOCv+ODr+ODvOODkOODiOODqyIsCiAgInN0YXJ0X3VybCI6ICIuLyIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzg3Q0VFQiIsCiAgInRoZW1lX2NvbG9yIjogIiM0MTY5RTEiLAogICJpY29ucyI6IFsKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVEk0SWlCb1pXbG5hSFE5SWpFeU9DSWdkbWxsZDBKdmVEMGlNQ0F3SURBNE1EQWdPREF3SWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpUGp3aVoyeHBlR1F0WjNKaFpHbGxiblFrWjNWNE1qQjdNRHM5TmpVbE8zUTJKaU5sUmc9PSIsCiAgICAgICJzaXplcyI6ICIxOTJ4MTkyIiwKICAgICAgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIKICAgIH0sCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTlRFeUlpQm9aV2xuYUhROU1qVTJJaUIyYVdWM1FtOTRQVEF3TURBd01qVTJNalUySWlCNGJXeHVjejFvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUk4WTJseVkyeGxJR040UFRFeU9DQmplVDF4TmpBaVBtbGpOREl3VURCQlFVRkJOemd6TURBQiIsCiAgICAgICJzaXplcyI6ICI1MTJ4NTEyIiwKICAgICAgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIKICAgIH0KICBdCn0=">

<meta name="theme-color" content="#4169E1">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="Animal Tower">
<link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDgwMCA4MDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDAsMTIwKSI+PGNpcmNsZSBjeD0iMzYwIiBjeT0iMzYwIiByPSIzMDAiIGZpbGw9IiM4N0NFRUIiLz48Y2lyY2xlIGN4PSIyODAiIGN5PSIyODAiIHI9IjUwIiBmaWxsPSIjNEE0QTRBIi8+PGNpcmNsZSBjeD0iNDQwIiBjeT0iMjgwIiByPSI1MCIgZmlsbD0iIzRBNEE0QSIvPjxwYXRoIGQ9Ik0zMDAgNDAwIFEzNjAgNDYwIDQyMCA0MDAiIHN0cm9rZT0iIzRBNEE0QSIgc3Ryb2tlLXdpZHRoPSI2IiBmaWxsPSJub25lIi8+PC9nPjwvc3ZnPg==">

<style>
  body { 
    margin: 0; 
    background: linear-gradient(135deg, #87CEEB, #E0F6FF);
    font-family: 'Arial', sans-serif;
    user-select: none;
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -webkit-tap-highlight-color: transparent;
    overflow-x: hidden;
  }
  
  #gameContainer {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px;
    min-height: 100vh;
  }
  
  canvas { 
    border: 3px solid #4169E1;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
  }
  
  #controls { 
    display: flex; 
    justify-content: center; 
    gap: 8px; 
    margin: 15px 0;
    flex-wrap: wrap;
    max-width: 100%;
  }
  
  button { 
    font-size: 14px; 
    padding: 10px 16px;
    border: none;
    border-radius: 8px;
    background: linear-gradient(145deg, #FFE4B5, #F0E68C);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    cursor: pointer;
    font-weight: bold;
    transition: all 0.1s;
    min-width: 60px;
    min-height: 44px;
    touch-action: manipulation;
    white-space: nowrap;
  }
  
  button:hover {
    background: linear-gradient(145deg, #F0E68C, #FFE4B5);
    transform: translateY(-1px);
  }
  
  button:active {
    transform: translateY(1px);
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
  }
  
  #gameInfo {
    text-align: center;
    margin: 10px 0;
    font-weight: bold;
    color: #333;
  }
  
  #scoreDisplay {
    font-size: 18px;
    color: #2E8B57;
    margin: 5px 0;
  }
  
  #audioControls {
    display: flex;
    gap: 10px;
    margin: 10px 0;
    flex-wrap: wrap;
    justify-content: center;
  }
  
  #volumeControl {
    display: flex;
    align-items: center;
    gap: 5px;
    background: rgba(255, 255, 255, 0.8);
    padding: 5px 10px;
    border-radius: 20px;
  }
  
  #volumeSlider {
    width: 80px;
  }
  
  .game-over {
    opacity: 0.6;
    pointer-events: none;
  }
  
  .loading {
    text-align: center;
    font-size: 18px;
    color: #666;
    margin: 20px;
  }
  
  #installPrompt {
    background: linear-gradient(145deg, #4CAF50, #45a049);
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    margin: 10px 0;
    cursor: pointer;
    font-weight: bold;
    display: none;
  }
  
  /* ã‚¹ãƒãƒ›å¯¾å¿œãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– */
  @media (max-width: 480px) {
    #gameContainer {
      padding: 5px;
    }
    
    canvas {
      max-width: calc(100vw - 20px);
      height: auto;
    }
    
    button {
      font-size: 12px;
      padding: 8px 12px;
      min-width: 50px;
    }
    
    #controls {
      gap: 5px;
      margin: 10px 0;
    }
  }
  
  .pwa-info {
    position: fixed;
    top: 10px;
    right: 10px;
    background: rgba(65, 105, 225, 0.9);
    color: white;
    padding: 5px 10px;
    border-radius: 20px;
    font-size: 12px;
    z-index: 1000;
  }
</style>
</head>
<body>
<div class="pwa-info">PWAå¯¾å¿œç‰ˆ</div>

<div id="gameContainer">
  <div id="gameInfo">
    <div>ã‚«ãƒ³ãƒ”ãƒ­ãã‚‰ãã‚‰</div>
    <div id="scoreDisplay">ã‚¹ã‚³ã‚¢: 0</div>
    <div id="loadingText" class="loading">ç”»åƒã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
    <div id="gameOverText" style="display: none; color: #ff0000; font-size: 24px; font-weight: bold;">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼</div>
  </div>
  
  <button id="installPrompt">ğŸ“± ã‚¢ãƒ—ãƒªã¨ã—ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«</button>
  
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  
  <div id="audioControls" style="display: none;">
    <button id="bgmToggle">ğŸµ BGM: ON</button>
    <div id="volumeControl">
      <span>ğŸ”Š</span>
      <input type="range" id="volumeSlider" min="0" max="100" value="30">
    </div>
  </div>
  
  <div id="controls" style="display: none;">
    <button id="leftBtn">â† å·¦</button>
    <button id="rightBtn">å³ â†’</button>
    <button id="rotateLeftBtn">âŸ² å·¦å›è»¢</button>
    <button id="rotateRightBtn">å³å›è»¢ âŸ³</button>
    <button id="dropBtn">ğŸ¾ è½ã¨ã™</button>
    <button id="resetBtn">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
  </div>
</div>

<!-- ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè¦ç´  -->
<audio id="bgmAudio" loop preload="auto">
  <!-- BGMãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚½ãƒ¼ã‚¹ã‚’æŒ‡å®šï¼ˆè¤‡æ•°å½¢å¼å¯¾å¿œï¼‰ -->
  <source src="bgm.mp3" type="audio/mpeg">
  <source src="bgm.ogg" type="audio/ogg">
  <source src="bgm.wav" type="audio/wav">
</audio>

<audio id="dropSound" preload="auto">
  <source src="drop.mp3" type="audio/mpeg">
  <source src="drop.ogg" type="audio/ogg">
  <source src="drop.wav" type="audio/wav">
</audio>

<audio id="gameOverSound" preload="auto">
  <source src="gameover.mp3" type="audio/mpeg">
  <source src="gameover.ogg" type="audio/ogg">
  <source src="gameover.wav" type="audio/wav">
</audio>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
// Service Workerç™»éŒ²
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('sw.js')
      .then(registration => {
        console.log('SW registered: ', registration);
      })
      .catch(registrationError => {
        console.log('SW registration failed: ', registrationError);
      });
  });
}

// PWA Install Prompt
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  document.getElementById('installPrompt').style.display = 'block';
});

document.getElementById('installPrompt').addEventListener('click', async () => {
  if (deferredPrompt) {
    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;
    console.log(`User response to the install prompt: ${outcome}`);
    deferredPrompt = null;
    document.getElementById('installPrompt').style.display = 'none';
  }
});

const { Engine, Render, Runner, Bodies, Composite, Body, Events } = Matter;

// ã‚²ãƒ¼ãƒ è¨­å®š
const GAME_CONFIG = {
    canvas: {
        width: 400,
        height: 600
    },
    ground: {
        widthRatio: 0.56,
        height: 25,
        color: '#8B4513'
    },
    physics: {
        gravity: 0.5,
        friction: 0.7,
        frictionStatic: 0.9,
        restitution: 0.2
    },
    animal: {
        targetSize: 90,
        minSize: 60,
        maxSize: 120,
        spawnHeight: 80,
        moveSpeed: 15,
        rotateSpeed: Math.PI / 12
    },
    performance: {
        targetFPS: 60,
        renderTiming: 16.67,
        inputThrottle: 50
    },
    audio: {
        bgmVolume: 0.3,
        sfxVolume: 0.5
    }
};

// ã‚²ãƒ¼ãƒ çŠ¶æ…‹
let gameState = {
    engine: null,
    render: null,
    runner: null,
    currentBody: null,
    isDropping: false,
    imagesLoaded: false,
    loadedImages: {},
    lastInputTime: 0,
    animationFrame: null,
    gameOver: false,
    score: 0,
    bgmEnabled: true,
    audioContext: null
};

// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè¦ç´ 
let audioElements = {
    bgm: null,
    dropSound: null,
    gameOverSound: null
};

// ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«å
const imageFiles = ['2.PNG', '3.PNG', '4.PNG', '5.PNG', '6.PNG', '8.PNG', '9.PNG', '11.PNG', '12.PNG'];

// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªåˆæœŸåŒ–
function initializeAudio() {
    audioElements.bgm = document.getElementById('bgmAudio');
    audioElements.dropSound = document.getElementById('dropSound');
    audioElements.gameOverSound = document.getElementById('gameOverSound');
    
    // éŸ³é‡è¨­å®š
    if (audioElements.bgm) {
        audioElements.bgm.volume = GAME_CONFIG.audio.bgmVolume;
        audioElements.bgm.load(); // ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰
    }
    
    if (audioElements.dropSound) {
        audioElements.dropSound.volume = GAME_CONFIG.audio.sfxVolume;
        audioElements.dropSound.load();
    }
    
    if (audioElements.gameOverSound) {
        audioElements.gameOverSound.volume = GAME_CONFIG.audio.sfxVolume;
        audioElements.gameOverSound.load();
    }
    
    // BGMã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«è¨­å®š
    const bgmToggle = document.getElementById('bgmToggle');
    const volumeSlider = document.getElementById('volumeSlider');
    
    bgmToggle.addEventListener('click', toggleBGM);
    volumeSlider.addEventListener('input', (e) => {
        const volume = e.target.value / 100;
        if (audioElements.bgm) {
            audioElements.bgm.volume = volume;
            GAME_CONFIG.audio.bgmVolume = volume;
        }
    });
    
    // åˆæœŸéŸ³é‡è¨­å®š
    volumeSlider.value = GAME_CONFIG.audio.bgmVolume * 100;
}

// BGMåˆ‡ã‚Šæ›¿ãˆ
function toggleBGM() {
    gameState.bgmEnabled = !gameState.bgmEnabled;
    const bgmToggle = document.getElementById('bgmToggle');
    
    if (gameState.bgmEnabled) {
        bgmToggle.textContent = 'ğŸµ BGM: ON';
        playBGM();
    } else {
        bgmToggle.textContent = 'ğŸ”‡ BGM: OFF';
        stopBGM();
    }
}

// BGMå†ç”Ÿ
function playBGM() {
    if (gameState.bgmEnabled && audioElements.bgm && !gameState.gameOver) {
        audioElements.bgm.play().catch(e => {
            console.log('BGMå†ç”Ÿå¤±æ•—:', e);
        });
    }
}

// BGMåœæ­¢
function stopBGM() {
    if (audioElements.bgm) {
        audioElements.bgm.pause();
        audioElements.bgm.currentTime = 0;
    }
}

// åŠ¹æœéŸ³å†ç”Ÿ
function playSoundEffect(soundName) {
    const audio = audioElements[soundName];
    if (audio) {
        audio.currentTime = 0;
        audio.play().catch(e => {
            console.log(`åŠ¹æœéŸ³${soundName}å†ç”Ÿå¤±æ•—:`, e);
        });
    }
}

// ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¾Œã«ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚’åˆæœŸåŒ–
function enableAudioOnUserInteraction() {
    const enableAudio = () => {
        if (!gameState.audioContext) {
            // Web Audio API ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
            try {
                gameState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log('Web Audio API not supported');
            }
        }
        
        // BGMè‡ªå‹•å†ç”Ÿã‚’è©¦è¡Œ
        setTimeout(() => {
            playBGM();
        }, 1000);
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
        document.removeEventListener('touchstart', enableAudio);
        document.removeEventListener('click', enableAudio);
        document.removeEventListener('keydown', enableAudio);
    };
    
    // æœ€åˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚’å¾…ã¤
    document.addEventListener('touchstart', enableAudio, { once: true });
    document.addEventListener('click', enableAudio, { once: true });
    document.addEventListener('keydown', enableAudio, { once: true });
}

// ç”»åƒã®æœ€é©ã‚µã‚¤ã‚ºã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°
function calculateOptimalScale(imgWidth, imgHeight, targetSize) {
    const aspectRatio = imgWidth / imgHeight;
    let scale;
    
    if (imgWidth >= imgHeight) {
        scale = targetSize / imgWidth;
    } else {
        scale = targetSize / imgHeight;
    }
    
    const resultWidth = imgWidth * scale;
    const resultHeight = imgHeight * scale;
    const maxDimension = Math.max(resultWidth, resultHeight);
    
    if (maxDimension > GAME_CONFIG.animal.maxSize) {
        scale = GAME_CONFIG.animal.maxSize / Math.max(imgWidth, imgHeight);
    } else if (maxDimension < GAME_CONFIG.animal.minSize) {
        scale = GAME_CONFIG.animal.minSize / Math.max(imgWidth, imgHeight);
    }
    
    return scale;
}

// ç”»åƒã‹ã‚‰è¼ªéƒ­ã‚’æŠ½å‡ºã—ã¦ãƒãƒªã‚´ãƒ³ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
function createPolygonFromImage(imageData, threshold = 128) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = imageData.image;
    const scale = imageData.scale;
    
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    
    const imgDataPixels = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const pixels = imgDataPixels.data;
    
    const contourPoints = [];
    const step = Math.max(1, Math.floor(Math.min(canvas.width, canvas.height) / 20));
    
    // å¤–å‘¨ã‚’ãƒˆãƒ¬ãƒ¼ã‚¹
    for (let y = 0; y < canvas.height; y += step) {
        for (let x = 0; x < canvas.width; x++) {
            const index = (y * canvas.width + x) * 4;
            const alpha = pixels[index + 3];
            
            if (alpha > threshold) {
                contourPoints.push({
                    x: (x - canvas.width / 2) * scale,
                    y: (y - canvas.height / 2) * scale
                });
                break;
            }
        }
        
        for (let x = canvas.width - 1; x >= 0; x--) {
            const index = (y * canvas.width + x) * 4;
            const alpha = pixels[index + 3];
            
            if (alpha > threshold) {
                const point = {
                    x: (x - canvas.width / 2) * scale,
                    y: (y - canvas.height / 2) * scale
                };
                const isDuplicate = contourPoints.some(p => 
                    Math.abs(p.x - point.x) < 5 && Math.abs(p.y - point.y) < 5
                );
                if (!isDuplicate) {
                    contourPoints.push(point);
                }
                break;
            }
        }
    }
    
    for (let x = 0; x < canvas.width; x += step) {
        for (let y = 0; y < canvas.height; y++) {
            const index = (y * canvas.width + x) * 4;
            const alpha = pixels[index + 3];
            
            if (alpha > threshold) {
                contourPoints.push({
                    x: (x - canvas.width / 2) * scale,
                    y: (y - canvas.height / 2) * scale
                });
                break;
            }
        }
        
        for (let y = canvas.height - 1; y >= 0; y--) {
            const index = (y * canvas.width + x) * 4;
            const alpha = pixels[index + 3];
            
            if (alpha > threshold) {
                const point = {
                    x: (x - canvas.width / 2) * scale,
                    y: (y - canvas.height / 2) * scale
                };
                const isDuplicate = contourPoints.some(p => 
                    Math.abs(p.x - point.x) < 5 && Math.abs(p.y - point.y) < 5
                );
                if (!isDuplicate) {
                    contourPoints.push(point);
                }
                break;
            }
        }
    }
    
    if (contourPoints.length < 3) {
        console.warn('è¼ªéƒ­æŠ½å‡ºã«å¤±æ•—ã€çŸ©å½¢ã‚’ä½¿ç”¨:', imageData);
        const w = canvas.width * scale / 2;
        const h = canvas.height * scale / 2;
        return [
            { x: -w, y: -h },
            { x: w, y: -h },
            { x: w, y: h },
            { x: -w, y: h }
        ];
    }
    
    const centerX = contourPoints.reduce((sum, p) => sum + p.x, 0) / contourPoints.length;
    const centerY = contourPoints.reduce((sum, p) => sum + p.y, 0) / contourPoints.length;
    
    contourPoints.sort((a, b) => {
        const angleA = Math.atan2(a.y - centerY, a.x - centerX);
        const angleB = Math.atan2(b.y - centerY, b.x - centerX);
        return angleA - angleB;
    });
    
    return simplifyPolygon(contourPoints, 16);
}

// ãƒãƒªã‚´ãƒ³ã‚’ç°¡ç´ åŒ–ã™ã‚‹é–¢æ•°
function simplifyPolygon(points, maxVertices) {
    if (points.length <= maxVertices) return points;
    
    const simplified = [];
    const step = Math.ceil(points.length / maxVertices);
    
    for (let i = 0; i < points.length; i += step) {
        simplified.push(points[i]);
    }
    
    return simplified;
}

// ç”»åƒã‚’ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰ã™ã‚‹é–¢æ•°
function preloadImages() {
    const loadingPromises = imageFiles.map(filename => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                const scale = calculateOptimalScale(img.width, img.height, GAME_CONFIG.animal.targetSize);
                const polygon = createPolygonFromImage({ image: img, scale: scale });
                
                gameState.loadedImages[filename] = {
                    image: img,
                    scale: scale,
                    width: img.width * scale,
                    height: img.height * scale,
                    polygon: polygon
                };
                resolve();
            };
            img.onerror = () => {
                console.warn(`ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—: ${filename}`);
                reject(new Error(`Failed to load ${filename}`));
            };
            img.src = filename;
        });
    });
    
    return Promise.allSettled(loadingPromises).then(results => {
        const successful = results.filter(result => result.status === 'fulfilled').length;
        console.log(`${successful}/${imageFiles.length} å€‹ã®ç”»åƒã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
        return successful > 0;
    });
}

// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
function checkGameOver() {
    if (gameState.gameOver) return;
    
    const bodies = Composite.allBodies(gameState.engine.world);
    const groundY = GAME_CONFIG.canvas.height - GAME_CONFIG.ground.height;
    
    for (let body of bodies) {
        if (body.isStatic) continue;
        
        if (body.bounds.max.y > groundY + 50) {
            triggerGameOver();
            return;
        }
    }
}

// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å‡¦ç†
function triggerGameOver() {
    if (gameState.gameOver) return;
    
    gameState.gameOver = true;
    
    // BGMåœæ­¢ã¨åŠ¹æœéŸ³å†ç”Ÿ
    stopBGM();
    playSoundEffect('gameOverSound');
    
    // UIæ›´æ–°
    document.getElementById('gameOverText').style.display = 'block';
    document.getElementById('controls').classList.add('game-over');
    
    // ã‚¨ãƒ³ã‚¸ãƒ³ã‚’åœæ­¢
    if (gameState.runner) {
        Runner.stop(gameState.runner);
    }
    
    // ç¾åœ¨ã®å‹•ç‰©ã‚’ã‚¯ãƒªã‚¢
    gameState.currentBody = null;
    gameState.isDropping = false;
    
    console.log('ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ æœ€çµ‚ã‚¹ã‚³ã‚¢:', gameState.score);
    
    // 3ç§’å¾Œã«ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã‚’å¼·èª¿
    setTimeout(() => {
        const resetBtn = document.getElementById('resetBtn');
        resetBtn.style.background = 'linear-gradient(145deg, #ff6b6b, #ff5252)';
        resetBtn.style.color = 'white';
        resetBtn.textContent = 'ğŸ”„ ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤';
    }, 3000);
}

// ã‚¹ã‚³ã‚¢ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
function updateScore() {
    gameState.score++;
    document.getElementById('scoreDisplay').textContent = `ã‚¹ã‚³ã‚¢: ${gameState.score}`;
}

// å…¥åŠ›åˆ¶é™ä»˜ãã®æ“ä½œé–¢æ•°
function throttledInput(callback) {
    const now = Date.now();
    if (now - gameState.lastInputTime > GAME_CONFIG.performance.inputThrottle && !gameState.gameOver) {
        gameState.lastInputTime = now;
        callback();
    }
}

// æœ€é©åŒ–ã•ã‚ŒãŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
function optimizedRender() {
    if (gameState.render) {
        gameState.animationFrame = requestAnimationFrame(optimizedRender);
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆåˆ¶å¾¡
        const now = performance.now();
        if (now - gameState.lastRenderTime >= GAME_CONFIG.performance.renderTiming) {
            Render.world(gameState.render);
            gameState.lastRenderTime = now;
        }
    }
}

// ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã®åˆæœŸåŒ–
function initializeGame() {
    const canvas = document.getElementById('gameCanvas');
    
    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’ã‚¹ãƒãƒ›å¯¾å¿œ
    const containerWidth = Math.min(400, window.innerWidth - 40);
    const containerHeight = Math.floor(containerWidth * 1.5); // 3:2ã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”
    
    canvas.width = containerWidth;
    canvas.height = containerHeight;
    
    GAME_CONFIG.canvas.width = containerWidth;
    GAME_CONFIG.canvas.height = containerHeight;
    
    // ã‚¨ãƒ³ã‚¸ãƒ³ã®ä½œæˆ
    gameState.engine = Engine.create();
    gameState.engine.world.gravity.y = GAME_CONFIG.physics.gravity;
    
    // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ä½œæˆ
    gameState.render = Render.create({
        canvas: canvas,
        engine: gameState.engine,
        options: {
            width: GAME_CONFIG.canvas.width,
            height: GAME_CONFIG.canvas.height,
            wireframes: false,
            background: 'transparent',
            showAngleIndicator: false,
            showVelocity: false,
            pixelRatio: Math.min(window.devicePixelRatio || 1, 2)
        }
    });
    
    // åœ°é¢ã®ä½œæˆ
    const groundWidth = GAME_CONFIG.canvas.width * GAME_CONFIG.ground.widthRatio;
    const ground = Bodies.rectangle(
        GAME_CONFIG.canvas.width / 2,
        GAME_CONFIG.canvas.height - GAME_CONFIG.ground.height / 2,
        groundWidth,
        GAME_CONFIG.ground.height,
        {
            isStatic: true,
            render: { fillStyle: GAME_CONFIG.ground.color },
            friction: GAME_CONFIG.physics.friction,
            frictionStatic: GAME_CONFIG.physics.frictionStatic
        }
    );
    
    // å·¦å³ã®è¦‹ãˆãªã„å£ã‚’è¿½åŠ 
    const wallThickness = 10;
    const leftWall = Bodies.rectangle(-wallThickness/2, GAME_CONFIG.canvas.height/2, wallThickness, GAME_CONFIG.canvas.height, { isStatic: true, render: { visible: false } });
    const rightWall = Bodies.rectangle(GAME_CONFIG.canvas.width + wallThickness/2, GAME_CONFIG.canvas.height/2, wallThickness, GAME_CONFIG.canvas.height, { isStatic: true, render: { visible: false } });
    
    Composite.add(gameState.engine.world, [ground, leftWall, rightWall]);
    
    // ãƒ©ãƒ³ãƒŠãƒ¼ã®ä½œæˆã¨é–‹å§‹
    gameState.runner = Runner.create();
    gameState.runner.delta = GAME_CONFIG.performance.renderTiming;
    Runner.run(gameState.runner, gameState.engine);
    
    // æœ€é©åŒ–ã•ã‚ŒãŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–‹å§‹
    gameState.lastRenderTime = 0;
    optimizedRender();
    
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
    setupEventListeners();
    
    // æœ€åˆã®å‹•ç‰©ã‚’ç”Ÿæˆ
    createRandomAnimal();
}

// ãƒ©ãƒ³ãƒ€ãƒ ãªå‹•ç‰©ã‚’ç”Ÿæˆ
function createRandomAnimal() {
    const availableImages = Object.keys(gameState.loadedImages);
    if (availableImages.length === 0) {
        console.error('ä½¿ç”¨å¯èƒ½ãªç”»åƒãŒã‚ã‚Šã¾ã›ã‚“');
        return;
    }
    
    const randomFilename = availableImages[Math.floor(Math.random() * availableImages.length)];
    const imageData = gameState.loadedImages[randomFilename];
    
    // ãƒãƒªã‚´ãƒ³ãƒœãƒ‡ã‚£ã‚’ä½œæˆ
    let body;
    try {
        body = Bodies.fromVertices(
            GAME_CONFIG.canvas.width / 2,
            GAME_CONFIG.animal.spawnHeight,
            [imageData.polygon],
            {
                friction: GAME_CONFIG.physics.friction,
                frictionStatic: GAME_CONFIG.physics.frictionStatic,
                restitution: GAME_CONFIG.physics.restitution,
                render: {
                    sprite: {
                        texture: randomFilename,
                        xScale: imageData.scale,
                        yScale: imageData.scale
                    }
                }
            },
            true
        );
    } catch (error) {
        console.warn('ãƒãƒªã‚´ãƒ³ãƒœãƒ‡ã‚£ä½œæˆã«å¤±æ•—ã€çŸ©å½¢ã§ä»£ç”¨:', error);
        body = Bodies.rectangle(
            GAME_CONFIG.canvas.width / 2,
            GAME_CONFIG.animal.spawnHeight,
            imageData.width,
            imageData.height,
            {
                friction: GAME_CONFIG.physics.friction,
                frictionStatic: GAME_CONFIG.physics.frictionStatic,
                restitution: GAME_CONFIG.physics.restitution,
                render: {
                    sprite: {
                        texture: randomFilename,
                        xScale: imageData.scale,
                        yScale: imageData.scale
                    }
                }
            }
        );
    }
    
    gameState.currentBody = body;
    Composite.add(gameState.engine.world, body);
}

// ç¾åœ¨ã®å‹•ç‰©ã‚’è½ä¸‹ã•ã›ã‚‹
function dropCurrentAnimal() {
    if (gameState.currentBody && !gameState.isDropping && !gameState.gameOver) {
        gameState.isDropping = true;
        updateScore();
        playSoundEffect('dropSound'); // è½ä¸‹éŸ³ã‚’å†ç”Ÿ
    }
}

// ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
function setupEventListeners() {
    // ç‰©ç†æ¼”ç®—ã®æ›´æ–°å‰å‡¦ç†
    Events.on(gameState.engine, 'beforeUpdate', () => {
        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒã‚§ãƒƒã‚¯
        checkGameOver();
        
        // è½ä¸‹ã—ã¦ã„ãªã„å ´åˆã¯é‡åŠ›ã‚’ç„¡åŠ¹åŒ–
        if (gameState.currentBody && !gameState.isDropping && !gameState.gameOver) {
            Body.setVelocity(gameState.currentBody, { x: 0, y: 0 });
            Body.setPosition(gameState.currentBody, {
                x: Math.max(gameState.currentBody.bounds.max.x - gameState.currentBody.bounds.min.x, 
                          Math.min(GAME_CONFIG.canvas.width - (gameState.currentBody.bounds.max.x - gameState.currentBody.bounds.min.x), 
                                  gameState.currentBody.position.x)),
                y: gameState.currentBody.position.y
            });
        }
        
        // è½ä¸‹ä¸­ã®å‹•ç‰©ãŒé™æ­¢ã—ãŸã‚‰æ¬¡ã®å‹•ç‰©ã‚’ç”Ÿæˆ
        if (gameState.currentBody && gameState.isDropping && !gameState.gameOver) {
            const velocity = gameState.currentBody.velocity;
            const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
            const angularSpeed = Math.abs(gameState.currentBody.angularVelocity);
            
            if (speed < 0.1 && angularSpeed < 0.01) {
                gameState.currentBody = null;
                gameState.isDropping = false;
                setTimeout(createRandomAnimal, 800);
            }
        }
    });
    
    // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆã‚¹ãƒ­ãƒƒãƒˆãƒªãƒ³ã‚°ä»˜ãï¼‰
    document.getElementById('leftBtn').onclick = () => {
        throttledInput(() => {
            if (gameState.currentBody && !gameState.isDropping && !gameState.gameOver) {
                Body.translate(gameState.currentBody, {x: -GAME_CONFIG.animal.moveSpeed, y: 0});
            }
        });
    };
    
    document.getElementById('rightBtn').onclick = () => {
        throttledInput(() => {
            if (gameState.currentBody && !gameState.isDropping && !gameState.gameOver) {
                Body.translate(gameState.currentBody, {x: GAME_CONFIG.animal.moveSpeed, y: 0});
            }
        });
    };
    
    document.getElementById('rotateLeftBtn').onclick = () => {
        throttledInput(() => {
            if (gameState.currentBody && !gameState.isDropping && !gameState.gameOver) {
                Body.rotate(gameState.currentBody, -GAME_CONFIG.animal.rotateSpeed);
            }
        });
    };
    
    document.getElementById('rotateRightBtn').onclick = () => {
        throttledInput(() => {
            if (gameState.currentBody && !gameState.isDropping && !gameState.gameOver) {
                Body.rotate(gameState.currentBody, GAME_CONFIG.animal.rotateSpeed);
            }
        });
    };
    
    document.getElementById('dropBtn').onclick = dropCurrentAnimal;
    
    document.getElementById('resetBtn').onclick = () => {
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢
        if (gameState.animationFrame) {
            cancelAnimationFrame(gameState.animationFrame);
        }
        location.reload();
    };
    
    // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆï¼ˆã‚¹ãƒãƒ›å¯¾å¿œï¼‰
    ['leftBtn', 'rightBtn', 'rotateLeftBtn', 'rotateRightBtn'].forEach(btnId => {
        const btn = document.getElementById(btnId);
        let touchInterval = null;
        
        const startAction = () => {
            btn.click();
            touchInterval = setInterval(() => btn.click(), 100);
        };
        
        const stopAction = () => {
            if (touchInterval) {
                clearInterval(touchInterval);
                touchInterval = null;
            }
        };
        
        // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startAction();
        });
        
        btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopAction();
        });
        
        btn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            stopAction();
        });
        
        // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
        btn.addEventListener('mousedown', startAction);
        btn.addEventListener('mouseup', stopAction);
        btn.addEventListener('mouseleave', stopAction);
    });
    
    // è½ã¨ã™ãƒœã‚¿ãƒ³ã¨ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã¯å˜ç™º
    ['dropBtn', 'resetBtn'].forEach(btnId => {
        const btn = document.getElementById(btnId);
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            btn.click();
        });
    });
    
    // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
    document.addEventListener('keydown', (event) => {
        switch(event.code) {
            case 'ArrowLeft':
            case 'KeyA':
                document.getElementById('leftBtn').click();
                break;
            case 'ArrowRight':
            case 'KeyD':
                document.getElementById('rightBtn').click();
                break;
            case 'KeyQ':
                document.getElementById('rotateLeftBtn').click();
                break;
            case 'KeyE':
                document.getElementById('rotateRightBtn').click();
                break;
            case 'Space':
            case 'ArrowDown':
            case 'KeyS':
                event.preventDefault();
                document.getElementById('dropBtn').click();
                break;
            case 'KeyR':
                document.getElementById('resetBtn').click();
                break;
            case 'KeyM':
                document.getElementById('bgmToggle').click();
                break;
        }
    });
    
    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
    window.addEventListener('resize', () => {
        setTimeout(() => {
            const canvas = document.getElementById('gameCanvas');
            const containerWidth = Math.min(400, window.innerWidth - 40);
            const containerHeight = Math.floor(containerWidth * 1.5);
            
            canvas.style.width = containerWidth + 'px';
            canvas.style.height = containerHeight + 'px';
        }, 100);
    });
}

// ã‚²ãƒ¼ãƒ åˆæœŸåŒ–ã¨ã‚¹ã‚¿ãƒ¼ãƒˆ
async function startGame() {
    document.getElementById('loadingText').textContent = 'ç”»åƒã‚’èª­ã¿è¾¼ã¿ä¸­...';
    
    // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªåˆæœŸåŒ–
    initializeAudio();
    enableAudioOnUserInteraction();
    
    try {
        const success = await preloadImages();
        
        if (success) {
            gameState.imagesLoaded = true;
            document.getElementById('loadingText').style.display = 'none';
            document.getElementById('scoreDisplay').style.display = 'block';
            document.getElementById('audioControls').style.display = 'flex';
            document.getElementById('controls').style.display = 'flex';
            
            initializeGame();
            
            console.log('ã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸï¼');
            console.log('æ“ä½œ: çŸ¢å°ã‚­ãƒ¼/WASD ã§ç§»å‹•ãƒ»å›è»¢ã€ã‚¹ãƒšãƒ¼ã‚¹/S ã§è½ä¸‹ã€R ã§ãƒªã‚»ãƒƒãƒˆã€M ã§BGMåˆ‡æ›¿');
            console.log('âš ï¸ å‹•ç‰©ãŒåœŸå°ã‹ã‚‰è½ã¡ã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã§ã™ï¼');
        } else {
            document.getElementById('loadingText').textContent = 'ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ1.PNGï½12.PNGï¼‰ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
            document.getElementById('loadingText').style.color = '#ff0000';
        }
    } catch (error) {
        console.error('ã‚²ãƒ¼ãƒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
        document.getElementById('loadingText').textContent = 'ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
        document.getElementById('loadingText').style.color = '#ff0000';
    }
}

// ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†å¾Œã«ã‚²ãƒ¼ãƒ é–‹å§‹
window.addEventListener('load', startGame);
