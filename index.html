アップロードボタン機能を削除するため、コード全体を書き直しました。以下の点を適用しています。

- 「画像追加」ボタンおよび関連処理を削除
- `1.png`〜`7.png`のみを対象としたプリロード
- プリロード後、配列からランダムに選択してゲーム進行
- UIから画像追加に関する操作要素を完全に排除

```html
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Custom Tower Game</title>
<style>
  body { margin: 0; background: #eef; }
  canvas { display: block; margin: auto; background: #ccf; }
  #controls { display: flex; justify-content: center; gap: 10px; margin: 5px; }
  button { font-size: 18px; padding: 5px 10px; }
</style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="600"></canvas>
<div id="controls">
  <button id="leftBtn">←</button>
  <button id="rightBtn">→</button>
  <button id="rotateLeftBtn">⟲</button>
  <button id="rotateRightBtn">⟳</button>
  <button id="dropBtn">落とす</button>
  <button id="resetBtn">R</button>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
const { Engine, Render, Runner, Bodies, Composite, Body, Events } = Matter;
const canvas = document.getElementById('gameCanvas');
const engine = Engine.create();
const render = Render.create({
    canvas: canvas,
    engine: engine,
    options: { width: canvas.width, height: canvas.height, wireframes: false, background: '#ccf' }
});

const groundWidth = canvas.width * 0.66;
const groundHeight = 20;
const ground = Bodies.rectangle(canvas.width / 2, canvas.height - groundHeight / 2, groundWidth, groundHeight, {
    isStatic: true, render: { fillStyle: '#964B00' }, friction: 1, frictionStatic: 1
});
Composite.add(engine.world, ground);

const imageFiles = ['1.PNG','2.PNG','3.PNG','4.PNG','5.PNG','6.PNG','7.PNG'];
let currentBody = null;
let isDropping = false;

function createRandomBody() {
    const imgFile = imageFiles[Math.floor(Math.random() * imageFiles.length)];
    const img = new Image();
    img.src = imgFile;
    img.onload = () => {
        const scale = (Math.random() * 0.16) + 0.18;
        const width = img.width * scale;
        const height = img.height * scale;
        const body = Bodies.rectangle(canvas.width / 2, 50, width, height, {
            friction: 0.65, frictionStatic: 0.9, restitution: 0.02,
            render: { sprite: { texture: imgFile, xScale: scale, yScale: scale } }
        });
        currentBody = body;
        Composite.add(engine.world, body);
    };
}

function dropCurrentBody() {
    if (currentBody) isDropping = true;
}

Events.on(engine, 'beforeUpdate', () => {
    if (currentBody && !isDropping) Body.setVelocity(currentBody, { x: 0, y: 0 });
    if (currentBody && isDropping) {
        currentBody = null;
        isDropping = false;
        setTimeout(createRandomBody, 500);
    }
});

document.getElementById('leftBtn').onclick = () => { if (currentBody) Body.translate(currentBody, {x: -10, y: 0}); };
document.getElementById('rightBtn').onclick = () => { if (currentBody) Body.translate(currentBody, {x: 10, y: 0}); };
document.getElementById('rotateLeftBtn').onclick = () => { if (currentBody) Body.rotate(currentBody, -Math.PI / 18); };
document.getElementById('rotateRightBtn').onclick = () => { if (currentBody) Body.rotate(currentBody, Math.PI / 18); };
document.getElementById('dropBtn').onclick = dropCurrentBody;
document.getElementById('resetBtn').onclick = () => location.reload();

Render.run(render);
const runner = Runner.create();
Runner.run(runner, engine);

createRandomBody();
</script>
</body>
</html>
```
