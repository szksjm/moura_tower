<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Animal Tower Battle</title>
<style>
  body { 
    margin: 0; 
    background: linear-gradient(135deg, #87CEEB, #E0F6FF);
    font-family: 'Arial', sans-serif;
    user-select: none;
  }
  
  #gameContainer {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px;
  }
  
  canvas { 
    border: 3px solid #4169E1;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
  }
  
  #controls { 
    display: flex; 
    justify-content: center; 
    gap: 12px; 
    margin: 15px 0;
    flex-wrap: wrap;
  }
  
  button { 
    font-size: 18px; 
    padding: 8px 16px;
    border: none;
    border-radius: 8px;
    background: linear-gradient(145deg, #FFE4B5, #F0E68C);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    cursor: pointer;
    font-weight: bold;
    transition: all 0.1s;
  }
  
  button:hover {
    background: linear-gradient(145deg, #F0E68C, #FFE4B5);
    transform: translateY(-1px);
  }
  
  button:active {
    transform: translateY(1px);
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
  }
  
  #gameInfo {
    text-align: center;
    margin: 10px 0;
    font-weight: bold;
    color: #333;
  }
  
  .loading {
    text-align: center;
    font-size: 18px;
    color: #666;
    margin: 20px;
  }
</style>
</head>
<body>
<div id="gameContainer">
  <div id="gameInfo">
    <div>å‹•ç‰©ã‚¿ãƒ¯ãƒ¼ãƒãƒˆãƒ«</div>
    <div id="loadingText" class="loading">ç”»åƒã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
  </div>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <div id="controls" style="display: none;">
    <button id="leftBtn">â† å·¦ç§»å‹•</button>
    <button id="rightBtn">å³ç§»å‹• â†’</button>
    <button id="rotateLeftBtn">âŸ² å·¦å›è»¢</button>
    <button id="rotateRightBtn">å³å›è»¢ âŸ³</button>
    <button id="dropBtn">ğŸ¾ è½ã¨ã™</button>
    <button id="resetBtn">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
const { Engine, Render, Runner, Bodies, Composite, Body, Events } = Matter;

// ã‚²ãƒ¼ãƒ è¨­å®š
const GAME_CONFIG = {
    canvas: {
        width: 400,
        height: 600
    },
    ground: {
        widthRatio: 0.7,
        height: 25,
        color: '#8B4513'
    },
    physics: {
        gravity: 0.5,
        friction: 0.7,
        frictionStatic: 0.9,
        restitution: 0.2
    },
    animal: {
        targetSize: 60,  // ç›®æ¨™ã‚µã‚¤ã‚ºï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
        minSize: 40,
        maxSize: 80,
        spawnHeight: 80,
        moveSpeed: 12,
        rotateSpeed: Math.PI / 16
    }
};

// ã‚²ãƒ¼ãƒ çŠ¶æ…‹
let gameState = {
    engine: null,
    render: null,
    runner: null,
    currentBody: null,
    isDropping: false,
    imagesLoaded: false,
    loadedImages: {}
};

// ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«å
const imageFiles = ['1.PNG', '2.PNG', '3.PNG', '4.PNG', '5.PNG', '6.PNG', '7.PNG'];

// ç”»åƒã®æœ€é©ã‚µã‚¤ã‚ºã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°
function calculateOptimalScale(imgWidth, imgHeight, targetSize) {
    const aspectRatio = imgWidth / imgHeight;
    let scale;
    
    // ç”»åƒã®æœ€å¤§ã‚µã‚¤ã‚ºï¼ˆå¹…ã¾ãŸã¯é«˜ã•ï¼‰ã‚’åŸºæº–ã«ã‚¹ã‚±ãƒ¼ãƒ«ã‚’æ±ºå®š
    if (imgWidth >= imgHeight) {
        // æ¨ªé•·ã®å ´åˆã¯å¹…ã‚’åŸºæº–ã«
        scale = targetSize / imgWidth;
    } else {
        // ç¸¦é•·ã®å ´åˆã¯é«˜ã•ã‚’åŸºæº–ã«
        scale = targetSize / imgHeight;
    }
    
    // æœ€å°ãƒ»æœ€å¤§ã‚µã‚¤ã‚ºã®åˆ¶é™
    const resultWidth = imgWidth * scale;
    const resultHeight = imgHeight * scale;
    const maxDimension = Math.max(resultWidth, resultHeight);
    
    if (maxDimension > GAME_CONFIG.animal.maxSize) {
        scale = GAME_CONFIG.animal.maxSize / Math.max(imgWidth, imgHeight);
    } else if (maxDimension < GAME_CONFIG.animal.minSize) {
        scale = GAME_CONFIG.animal.minSize / Math.max(imgWidth, imgHeight);
    }
    
    return scale;
}

// ç”»åƒã‚’ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰ã™ã‚‹é–¢æ•°
function preloadImages() {
    const loadingPromises = imageFiles.map(filename => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                // æœ€é©ãªã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¨ˆç®—
                const scale = calculateOptimalScale(img.width, img.height, GAME_CONFIG.animal.targetSize);
                
                gameState.loadedImages[filename] = {
                    image: img,
                    scale: scale,
                    width: img.width * scale,
                    height: img.height * scale
                };
                resolve();
            };
            img.onerror = () => {
                console.warn(`ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—: ${filename}`);
                reject(new Error(`Failed to load ${filename}`));
            };
            img.src = filename;
        });
    });
    
    return Promise.allSettled(loadingPromises).then(results => {
        const successful = results.filter(result => result.status === 'fulfilled').length;
        console.log(`${successful}/${imageFiles.length} å€‹ã®ç”»åƒã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
        return successful > 0;
    });
}

// ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã®åˆæœŸåŒ–
function initializeGame() {
    const canvas = document.getElementById('gameCanvas');
    
    // ã‚¨ãƒ³ã‚¸ãƒ³ã®ä½œæˆ
    gameState.engine = Engine.create();
    gameState.engine.world.gravity.y = GAME_CONFIG.physics.gravity;
    
    // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ä½œæˆ
    gameState.render = Render.create({
        canvas: canvas,
        engine: gameState.engine,
        options: {
            width: GAME_CONFIG.canvas.width,
            height: GAME_CONFIG.canvas.height,
            wireframes: false,
            background: 'transparent',
            showAngleIndicator: false,
            showVelocity: false
        }
    });
    
    // åœ°é¢ã®ä½œæˆ
    const groundWidth = GAME_CONFIG.canvas.width * GAME_CONFIG.ground.widthRatio;
    const ground = Bodies.rectangle(
        GAME_CONFIG.canvas.width / 2,
        GAME_CONFIG.canvas.height - GAME_CONFIG.ground.height / 2,
        groundWidth,
        GAME_CONFIG.ground.height,
        {
            isStatic: true,
            render: { fillStyle: GAME_CONFIG.ground.color },
            friction: GAME_CONFIG.physics.friction,
            frictionStatic: GAME_CONFIG.physics.frictionStatic
        }
    );
    
    // å·¦å³ã®è¦‹ãˆãªã„å£ã‚’è¿½åŠ ï¼ˆå‹•ç‰©ãŒç”»é¢å¤–ã«è½ã¡ãªã„ã‚ˆã†ã«ï¼‰
    const wallThickness = 10;
    const leftWall = Bodies.rectangle(-wallThickness/2, GAME_CONFIG.canvas.height/2, wallThickness, GAME_CONFIG.canvas.height, { isStatic: true, render: { visible: false } });
    const rightWall = Bodies.rectangle(GAME_CONFIG.canvas.width + wallThickness/2, GAME_CONFIG.canvas.height/2, wallThickness, GAME_CONFIG.canvas.height, { isStatic: true, render: { visible: false } });
    
    Composite.add(gameState.engine.world, [ground, leftWall, rightWall]);
    
    // ãƒ©ãƒ³ãƒŠãƒ¼ã®ä½œæˆã¨é–‹å§‹
    gameState.runner = Runner.create();
    Runner.run(gameState.runner, gameState.engine);
    Render.run(gameState.render);
    
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
    setupEventListeners();
    
    // æœ€åˆã®å‹•ç‰©ã‚’ç”Ÿæˆ
    createRandomAnimal();
}

// ãƒ©ãƒ³ãƒ€ãƒ ãªå‹•ç‰©ã‚’ç”Ÿæˆ
function createRandomAnimal() {
    const availableImages = Object.keys(gameState.loadedImages);
    if (availableImages.length === 0) {
        console.error('ä½¿ç”¨å¯èƒ½ãªç”»åƒãŒã‚ã‚Šã¾ã›ã‚“');
        return;
    }
    
    const randomFilename = availableImages[Math.floor(Math.random() * availableImages.length)];
    const imageData = gameState.loadedImages[randomFilename];
    
    const body = Bodies.rectangle(
        GAME_CONFIG.canvas.width / 2,
        GAME_CONFIG.animal.spawnHeight,
        imageData.width,
        imageData.height,
        {
            friction: GAME_CONFIG.physics.friction,
            frictionStatic: GAME_CONFIG.physics.frictionStatic,
            restitution: GAME_CONFIG.physics.restitution,
            render: {
                sprite: {
                    texture: randomFilename,
                    xScale: imageData.scale,
                    yScale: imageData.scale
                }
            }
        }
    );
    
    gameState.currentBody = body;
    Composite.add(gameState.engine.world, body);
}

// ç¾åœ¨ã®å‹•ç‰©ã‚’è½ä¸‹ã•ã›ã‚‹
function dropCurrentAnimal() {
    if (gameState.currentBody && !gameState.isDropping) {
        gameState.isDropping = true;
    }
}

// ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
function setupEventListeners() {
    // ç‰©ç†æ¼”ç®—ã®æ›´æ–°å‰å‡¦ç†
    Events.on(gameState.engine, 'beforeUpdate', () => {
        // è½ä¸‹ã—ã¦ã„ãªã„å ´åˆã¯é‡åŠ›ã‚’ç„¡åŠ¹åŒ–ï¼ˆå®™ã«æµ®ã‹ã›ã‚‹ï¼‰
        if (gameState.currentBody && !gameState.isDropping) {
            Body.setVelocity(gameState.currentBody, { x: 0, y: 0 });
            Body.setPosition(gameState.currentBody, {
                x: Math.max(gameState.currentBody.bounds.max.x - gameState.currentBody.bounds.min.x, 
                          Math.min(GAME_CONFIG.canvas.width - (gameState.currentBody.bounds.max.x - gameState.currentBody.bounds.min.x), 
                                  gameState.currentBody.position.x)),
                y: gameState.currentBody.position.y
            });
        }
        
        // è½ä¸‹ä¸­ã®å‹•ç‰©ãŒé™æ­¢ã—ãŸã‚‰æ¬¡ã®å‹•ç‰©ã‚’ç”Ÿæˆ
        if (gameState.currentBody && gameState.isDropping) {
            const velocity = gameState.currentBody.velocity;
            const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
            
            if (speed < 0.1) {
                gameState.currentBody = null;
                gameState.isDropping = false;
                setTimeout(createRandomAnimal, 800);
            }
        }
    });
    
    // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
    document.getElementById('leftBtn').onclick = () => {
        if (gameState.currentBody && !gameState.isDropping) {
            Body.translate(gameState.currentBody, {x: -GAME_CONFIG.animal.moveSpeed, y: 0});
        }
    };
    
    document.getElementById('rightBtn').onclick = () => {
        if (gameState.currentBody && !gameState.isDropping) {
            Body.translate(gameState.currentBody, {x: GAME_CONFIG.animal.moveSpeed, y: 0});
        }
    };
    
    document.getElementById('rotateLeftBtn').onclick = () => {
        if (gameState.currentBody && !gameState.isDropping) {
            Body.rotate(gameState.currentBody, -GAME_CONFIG.animal.rotateSpeed);
        }
    };
    
    document.getElementById('rotateRightBtn').onclick = () => {
        if (gameState.currentBody && !gameState.isDropping) {
            Body.rotate(gameState.currentBody, GAME_CONFIG.animal.rotateSpeed);
        }
    };
    
    document.getElementById('dropBtn').onclick = dropCurrentAnimal;
    
    document.getElementById('resetBtn').onclick = () => {
        location.reload();
    };
    
    // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ
    document.addEventListener('keydown', (event) => {
        switch(event.code) {
            case 'ArrowLeft':
            case 'KeyA':
                document.getElementById('leftBtn').click();
                break;
            case 'ArrowRight':
            case 'KeyD':
                document.getElementById('rightBtn').click();
                break;
            case 'KeyQ':
                document.getElementById('rotateLeftBtn').click();
                break;
            case 'KeyE':
                document.getElementById('rotateRightBtn').click();
                break;
            case 'Space':
            case 'ArrowDown':
            case 'KeyS':
                event.preventDefault();
                document.getElementById('dropBtn').click();
                break;
            case 'KeyR':
                document.getElementById('resetBtn').click();
                break;
        }
    });
}

// ã‚²ãƒ¼ãƒ åˆæœŸåŒ–ã¨ã‚¹ã‚¿ãƒ¼ãƒˆ
async function startGame() {
    document.getElementById('loadingText').textContent = 'ç”»åƒã‚’èª­ã¿è¾¼ã¿ä¸­...';
    
    try {
        const success = await preloadImages();
        
        if (success) {
            gameState.imagesLoaded = true;
            document.getElementById('loadingText').style.display = 'none';
            document.getElementById('controls').style.display = 'flex';
            
            initializeGame();
            
            console.log('ã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸï¼');
            console.log('æ“ä½œ: çŸ¢å°ã‚­ãƒ¼/WASD ã§ç§»å‹•ãƒ»å›è»¢ã€ã‚¹ãƒšãƒ¼ã‚¹/S ã§è½ä¸‹ã€R ã§ãƒªã‚»ãƒƒãƒˆ');
        } else {
            document.getElementById('loadingText').textContent = 'ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ1.PNGï½7.PNGï¼‰ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
            document.getElementById('loadingText').style.color = '#ff0000';
        }
    } catch (error) {
        console.error('ã‚²ãƒ¼ãƒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
        document.getElementById('loadingText').textContent = 'ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
        document.getElementById('loadingText').style.color = '#ff0000';
    }
}

// ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†å¾Œã«ã‚²ãƒ¼ãƒ é–‹å§‹
window.addEventListener('load', startGame);
</script>
</body>
</html>
